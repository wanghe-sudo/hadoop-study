开发一个计算每个月最高温度的两天

这里充分使用了mapreduce的所有信息


map阶段：

1. input 将数据读入
2. map 进行map处理
3. output 进行输出【这里会输出为kvp，写入环形缓冲区，索引16b，p（分区），ks（key开始index），vs（value index），vl（value 长度）】

map阶段会将数【K（序列化），V（序列化），P】放入环形缓冲区（从头往尾，放KV；从尾往头，放索引【16k：partition 4，key start index 4，value start index 4，value length 4】），因此索引块儿大小始终是16K。默认大小是100M，80%会发生溢写，写下的数据是有序的

溢写时，先锁住已有数据

Buffer缓冲区到达阈值，启动线程，快排80%的数据到磁盘，快排逻辑：比较key的索引，排序是二次排序，分区有序，分区内key有序

最后reduce拉取，是按照分区拉取
当数据达到80%后，会启动线程进行快排，是比较key排序
最终，溢写时，只要按照排序索引，写入文件，排序是二次排序，分区有序（reduce按分区拉取数据），分区内key有序（reduce计算是按照分组计算，分组的语义，相同的key为一组）
4. combiner：map中，按组进行reduce计算，在内存溢写数据之前，排序之后，溢写的IO变少。最终map输出结束，输出过程中，buffer溢写出多个小文件，这里可以设置参数，默认是minSpillsForCombiner=3，就会触发map合并（多个小文件合并，合并的好处就是避免小文件的碎片化对未来reduce拉取数据造成的随机读取）
combiner注意，必须是幂等，例子：求和计算
假如是求平均数，就没办法combiner








reduce阶段：

有多少个reduce，默认就会有多少个reduce分区 




排序比较器
分组比较器


优先取用户覆盖的自定义比较器
保底，取可以这个类型自身的比较器

maptask                         reducetask
1.用户定义的排序比较器              1.取用户自定义的分组比较器
2.取key自身的排序比较器             2.用户自定义的排序比较器
                                 3.取key自身的排序比较器


组合方式：
1)设置排序和分组比较器：
    map:取key自身的排序比较器
    reduce:取key自身的排序比较器
2)设置了排序
    map:用户定义的排序比较器
    reduce:用户定义的排序比较器
3)设置芋分组
    map:取key自身的排序比较器
    reduce:取用户自定义的分组比较器
4)设置了排序和分组
    map:用户定义的排序比较器
    reduce:取用户自定义的分组比较器
做减法：结论，框架很灵活，给了我们各种加工数据排序和分组的方式